<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://biofang.github.io/"/>
  <updated>2024-03-19T13:47:53.561Z</updated>
  <id>https://biofang.github.io/</id>
  
  <author>
    <name>Fangj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测序数据损坏简单修复</title>
    <link href="https://biofang.github.io/2024/03/19/%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%9D%8F%E7%AE%80%E5%8D%95%E4%BF%AE%E5%A4%8D/"/>
    <id>https://biofang.github.io/2024/03/19/测序数据损坏简单修复/</id>
    <published>2024-03-19T13:41:57.000Z</published>
    <updated>2024-03-19T13:47:53.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;如果服务器硬盘坏了，数据恢复的可能性存在，但并不是百分之百。<br>&emsp;&emsp;首先需要知道的是，数据恢复的难度与硬盘故障的类型和程度密切相关。如果是物理损坏，比如电路板故障或者盘片划伤等，恢复的难度会非常大，而且通常无法保证能够完全恢复所有数据。如果是逻辑损坏，比如文件系统错误或者病毒攻击等，恢复的难度相对较小，但也需要根据具体情况而定。<br>&emsp;&emsp;<strong>针对服务器数据恢复，以下是一些可能的步骤：</strong></p><ul><li><strong>备份数据</strong>：<ul><li>在服务器硬盘损坏后，首先要做的是备份所有数据。这可以通过使用专业的数据恢复设备或者硬盘拷贝机来实现。要确保备份的数据完整性和准确性，需要在备份过程中仔细操作并检查。</li></ul></li><li><strong>修复硬盘</strong>：<ul><li>对于物理损坏的硬盘，需要进行修复。这通常包括更换电路板、修复盘片或者更换整个硬盘等。在这个过程中，需要非常小心，以免对硬盘造成更大的损坏。</li></ul></li><li><strong>数据恢复</strong>：<ul><li>在备份完数据并修复好硬盘后，可以开始进行数据恢复。这通常包括在专业的数据恢复设备上对硬盘进行镜像备份、分析raid信息、尝试恢复丢失的数据等。这个过程需要专业的技能和经验，不能随意操作。</li></ul></li></ul><p>&emsp;&emsp;需要注意的是，在数据恢复过程中，任何操作都可能对原始数据造成破坏，因此最好避免在原盘上进行数据分析、重组等操作。同时，如果发现有无法恢复的数据，不要继续尝试，以免对数据造成更大的破坏。</p><p><strong>以上是常规磁盘数据恢复过程，由专业的服务器运维工程师操作。</strong></p><p>当样本下机fastq.gz文件通过以上专业方式依然无法恢复时，我们可以通过生信方式尽量多的从损坏文件中获取有用信息，尽可能降低损失。</p><a id="more"></a><h2 id="损坏文件修复"><a href="#损坏文件修复" class="headerlink" title="损坏文件修复"></a>损坏文件修复</h2><h3 id="整体修复流程"><a href="#整体修复流程" class="headerlink" title="整体修复流程"></a>整体修复流程</h3><p>损坏fastq.gz文件修复整体流程如下：</p><p><img src="https://s2.loli.net/2024/03/19/hFtWmUsMYR21eKP.png" alt="文件修复流程图"></p><h3 id="gzip压缩原理"><a href="#gzip压缩原理" class="headerlink" title="gzip压缩原理"></a>gzip压缩原理</h3><p>&emsp;&emsp;根据gzip算法的压缩原理，已知修复一个损坏的gzip文件的关键环节在于找到下一个正常压缩包的起始点。根据结构图中的信息可知，每个压缩包的开始结构中有是否到达尾部标志、使用的哈夫曼树类型、以及3个哈夫曼树的树元素个数等。如果某个gzip文件中间有一个坏扇区，要找到坏扇区后的一个正常起点，仅需按位右移，一直移位到可以正常解压的某个位，就可能找到了正确的压缩包起始。而根据gzip文件的压缩作业窗口为32KB大小推算，这个遍历不会超过64KB即可找到。在内存中快速循环可以很快找到，但需要有明确的判断错误的方法。</p><p><img src="https://s2.loli.net/2024/03/19/cbrZBO7tQa1DSqe.png" alt="gzip结构图"></p><p>理论上我们可以对gzip的源码（C语言）做修改，进行遍历找出损坏点后的有用数据。但实际上可操作性较低，我们只能借助其它现成的工具。</p><h3 id="fastq-gz文件损坏判断"><a href="#fastq-gz文件损坏判断" class="headerlink" title="fastq.gz文件损坏判断"></a>fastq.gz文件损坏判断</h3><p>使用<code>seqkit stat</code>命令，查看fastq文件基本统计信息是否正常输出；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seqkit stat -a WL102PD1Mg_HN2HKCCXY-L7_R1.fastq.gz</span><br><span class="line">[ERRO] WL102PD1Mg_HN2HKCCXY-L7_R1.fastq.gz: gzip: invalid checksum</span><br></pre></td></tr></table></figure><h3 id="gzrecover-软件"><a href="#gzrecover-软件" class="headerlink" title="gzrecover 软件"></a>gzrecover 软件</h3><p>gihub上开源的 <a href="https://github.com/arenn/gzrt" target="_blank" rel="noopener">gzrecover</a>软件可以从已损坏的gzip文件中提取任何可读内容，用于损坏gz文件修复。</p><p><strong>软件官网及参数如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/arenn/gzrt</span><br><span class="line"></span><br><span class="line">gzrecover - Recover data from a corrupted gzip file</span><br><span class="line"></span><br><span class="line">gzrecover is a program that will attempt to extract any readable data out of a gzip file that has been corrupted. </span><br><span class="line"></span><br><span class="line">Options include:</span><br><span class="line"></span><br><span class="line">-o &lt;name&gt; - Sets the output file name</span><br><span class="line">-p        - Write output to standard output for pipeline support</span><br><span class="line">-s        - Splits each recovered segment into its own file,</span><br><span class="line">            with numeric suffixes (.1, .2, etc) (UNTESTED)</span><br><span class="line">-h        - Print the help message</span><br><span class="line">-v        - Verbose logging on</span><br><span class="line">-V        - Print version number</span><br><span class="line"></span><br><span class="line"># 使用案例</span><br><span class="line">./gzrecover demo_R1.fq.gz -o demo.R1.recovered</span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><ul><li>未损坏的gz文件，不建议使用gzrecover软件处理；</li><li>gzrecover恢复后的内容中，依然有乱码，需要进一步处理；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 乱码情况可能出现中文件的开头、中间等地方</span><br><span class="line"></span><br><span class="line">1 7jNPￃ&lt;81&gt;S&lt;C0&gt;^Mo&quot;&lt;F3&gt;^L&lt;D8&gt;&lt;FB&gt;4&lt;88&gt;5^0^D]z&lt;U+063B&gt;^Z&lt;D8&gt;|_R&lt;B2&gt;&lt;98&gt;y&lt;FE&gt;[^BGU&lt;E0&gt;&lt;D9&gt;^FS #Pboe&lt;C2&gt;[i:&lt;B9&gt;?U&lt;F5&gt;&quot;&lt;85&gt;&lt;C8&gt;HV&lt;A8&gt;_1^F^ZM&lt;E5&gt;&lt;E2&gt;T^Y&lt;8E&gt;8+KՔh&lt;9F&gt;J^P~&lt;A9&gt;</span><br><span class="line">2 &lt;E4&gt;&lt;A0&gt;^MݏF&lt;DF&gt;^PK%^]&lt;D2&gt;;HbC&lt;F4&gt;ESCK&lt;D5&gt;(&lt;8B&gt;^Nt&lt;89&gt;&apos;X&lt;B6&gt;^X^AY&lt;8F&gt;&lt;D7&gt;W^]&lt;AD&gt;t^]C&lt;87&gt;j&lt;BF&gt;X&lt;B6&gt;^X^AY&lt;8F&gt;&lt;D7&gt;ESC&lt;D9&gt;&lt;CF&gt;&lt;D5&gt;=^^&lt;99&gt;^^&lt;99&gt;^^&lt;99&gt;&lt;88&gt;&lt;8E&gt;^M&lt;F2&gt;^ER&lt;9A&gt;0X&lt;9D&gt;^Y^@</span><br><span class="line">3 GGTCTGTTGAGGTCGTCAAAAGGGACAGGATCCTCTTAATTGAATTAAACCTAAATTTACCCCAGAGCTATATGAGGGAGAGTTAGATACCTGAAAAATTGAGGATTTACCTTGCCCCAAGAAAAGATGGAATAATATGTTTGGTATAGA</span><br><span class="line">4 +</span><br><span class="line">5 FFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFF</span><br><span class="line">6 @A00459:269:H5HHMDSX3:2:1101:11912:1485 2:N:0:CATTGCCT+GTTCTCAG</span><br><span class="line">7 GGTCAAGGCTGGACCCATCCCCATCTCACCAGCAGCACAGTCAGATTCAGACACAGGTATTCAACTTTGCAACACACTGTGCCTCACGGCCAGTGTGCTCAACATCAGAAATCAAATAGAAAATCCCACATTCTAAGATTCATATCCATC</span><br><span class="line">8 +</span><br></pre></td></tr></table></figure></li></ul><h3 id="fastq信息提取"><a href="#fastq信息提取" class="headerlink" title="fastq信息提取"></a>fastq信息提取</h3><p>损坏的fastq.gz文件经过gzrecover修复后，使用python 程序能够正常读取到<strong>文件结尾</strong>。</p><p><strong>正常的fastq文件是4行为一个单元（unit）：</strong></p><ul><li>第1行主要储存序列测序时的坐标等信息；</li><li>第2行是测序得到的序列信息；</li><li>第3行以“+”开始，可以储存一些附加信息，一般是空的；</li><li>第4行储存的是质量信息；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ST-E00126:128:HJFLHCCXX:2:1101:7405:1133</span><br><span class="line">TTGCAAAAAATTTCTCTCATTCTGTAGGTTGCCTGTTCACTCTGATGATAGTTTGTTTTGG</span><br><span class="line">+</span><br><span class="line">FFKKKFKKFKF&lt;KK&lt;F,AFKKKKK7FFK77&lt;FKK,&lt;F7K,,7AF&lt;FF7FKK7AA,7&lt;FA,,</span><br></pre></td></tr></table></figure></li></ul><p>fastq.gz文件损坏后，可能会导致fastq文件内容部分丢失，比如缺失reads中的某一两行。因此，对gzrecover软件修复的fastq文件，在正式使用前，还需要进行预处理：</p><ol><li>将fastq文件内容按照四行（@，150bp序列，+，150个质量信息）为一个单元进行整理，如果四行中缺少某行（或某部分），则整个单元丢弃；</li><li>reads1与reads2 ID名称对应，未对应的则丢弃；</li><li>对应上的ID 在fastq1、fastq2文件中前后相邻的ID也要一一对应，否则丢弃；</li><li>经过两次过滤后，最终保留的reads，可正常使用。</li></ol><p>参考使用脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import sys </span><br><span class="line">import re</span><br><span class="line">import os </span><br><span class="line">import gzip</span><br><span class="line">import argparse</span><br><span class="line">from collections import deque</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">usage = &apos;&apos;&apos;</span><br><span class="line">Description:</span><br><span class="line">    Designed to extract reads from fastq (fastq.gz,fastq.recovered) files!\n</span><br><span class="line">&apos;&apos;&apos;.format(src=(__file__[__file__.rfind(os.sep) + 1:]))</span><br><span class="line"></span><br><span class="line">def options():</span><br><span class="line">    parser = argparse.ArgumentParser(formatter_class= argparse.RawTextHelpFormatter,description=usage)</span><br><span class="line">    parser.add_argument(&quot;-1&quot;,&apos;--fq1&apos;, help=&apos;Input fastq R1 file&apos;, dest=&apos;fq1&apos;, type=str, action=&apos;store&apos;, required=True)</span><br><span class="line">    parser.add_argument(&quot;-2&quot;,&apos;--fq2&apos;, help=&apos;Input fastq R2 file&apos;, dest=&apos;fq2&apos;, type=str, action=&apos;store&apos;, required=True)</span><br><span class="line">    parser.add_argument(&quot;-s&quot;,&apos;--sample&apos;, help=&apos;Input sample name,(default: %(default)s)&apos;, dest=&apos;sample&apos;, type=str, action=&apos;store&apos;, default=&quot;Test&quot;)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    return args</span><br><span class="line"></span><br><span class="line"># reads 4行判断（边读取边判断）;</span><br><span class="line">def get_fq_dict(in_file):</span><br><span class="line">    fq_unit_dict = &#123;&#125;     # id: &#123;seq,plus,qua,pos&#125;</span><br><span class="line">    pos_id_dict = &#123;&#125;      # pos:id </span><br><span class="line">    ele_deque = deque()</span><br><span class="line">    if in_file.endswith(&quot;.gz&quot;):    # gz压缩格式</span><br><span class="line">        inf = gzip.open(in_file,&quot;rt&quot;)</span><br><span class="line">    else:</span><br><span class="line">        inf = open(in_file,&quot;r&quot;,encoding=&apos;latin-1&apos;) # latin-1 for qsub</span><br><span class="line"></span><br><span class="line">    pos = 0   # reads 起始位置</span><br><span class="line">    </span><br><span class="line">    for line in inf:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        ele_deque.append(line)</span><br><span class="line">        if len(ele_deque) == 4:</span><br><span class="line">            if ele_deque[0].startswith(&quot;@&quot;) and ele_deque[2] == &quot;+&quot; and len(ele_deque[1]) == 150 and len(ele_deque[3]) == 150:</span><br><span class="line">                key = re.split(r&quot;\s+&quot;,ele_deque[0])[0].replace(&quot;@&quot;,&quot;&quot;)    # 提取read1,read2 名称共有部分；</span><br><span class="line">                ele_deque.append(pos)</span><br><span class="line">                fq_unit_dict[key] = tuple(ele_deque.copy())       # to tuple  </span><br><span class="line">                pos_id_dict[pos] = key                      </span><br><span class="line">                ele_deque.clear()                                 </span><br><span class="line">                pos += 1</span><br><span class="line">            else:</span><br><span class="line">                ele_deque.popleft()</span><br><span class="line">    inf.close()</span><br><span class="line">    return fq_unit_dict,pos_id_dict</span><br><span class="line"></span><br><span class="line">def get_pos_info(all_fq_nums,r_pos,fq_pos_id_dict):</span><br><span class="line">    fq_nums = all_fq_nums - 1</span><br><span class="line">    if fq_nums &gt; r_pos &gt; 0: </span><br><span class="line">        r_front_pos = r_pos - 1 </span><br><span class="line">        r_back_pos = r_pos + 1</span><br><span class="line">    elif r_pos == 0:</span><br><span class="line">        r_front_pos = 0 </span><br><span class="line">        r_back_pos = r_pos + 1</span><br><span class="line">    else:</span><br><span class="line">        r_front_pos = r_pos - 1 </span><br><span class="line">        r_back_pos = fq_nums</span><br><span class="line">    r_front_id = fq_pos_id_dict[r_front_pos]</span><br><span class="line">    r_back_id = fq_pos_id_dict[r_back_pos]</span><br><span class="line">    return r_front_id,r_back_id</span><br><span class="line"></span><br><span class="line">def run_process(fq1_file,fq2_file):</span><br><span class="line">    files_list = [fq1_file,fq2_file]</span><br><span class="line">    tmp_list = []</span><br><span class="line">    pool = Pool(2)</span><br><span class="line">    for file in files_list:</span><br><span class="line">        tmp_list.append(pool.apply_async(get_fq_dict,args=(file,)))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    fq1_unit_dict, fq1_pos_id_dict = tmp_list[0].get()</span><br><span class="line">    fq2_unit_dict, fq2_pos_id_dict = tmp_list[1].get()</span><br><span class="line">    return fq1_unit_dict, fq1_pos_id_dict,fq2_unit_dict, fq2_pos_id_dict</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    args = options()</span><br><span class="line"></span><br><span class="line">    fq1_file = args.fq1</span><br><span class="line">    fq2_file = args.fq2</span><br><span class="line">    prefix = args.sample</span><br><span class="line"></span><br><span class="line">    outfq1_file = f&quot;&#123;prefix&#125;_gzrecover_R1.fastq.gz&quot;</span><br><span class="line">    outfq2_file = f&quot;&#123;prefix&#125;_gzrecover_R2.fastq.gz&quot;</span><br><span class="line">    log_file = f&quot;&#123;prefix&#125;.gzrecover.log&quot;</span><br><span class="line"></span><br><span class="line">    fq1_unit_dict,fq1_pos_id_dict,fq2_unit_dict,fq2_pos_id_dict = run_process(fq1_file,fq2_file)</span><br><span class="line"></span><br><span class="line">    fq1_nums = len(fq1_unit_dict)</span><br><span class="line">    fq2_nums = len(fq2_unit_dict)</span><br><span class="line"></span><br><span class="line">    id_match_num = 0</span><br><span class="line">    id_pos_match_num = 0</span><br><span class="line"></span><br><span class="line">    with gzip.open(outfq1_file,&apos;wt&apos;) as outfq1, gzip.open(outfq2_file,&apos;wt&apos;) as outfq2,open(log_file,&apos;w&apos;) as outlog:</span><br><span class="line">        outlog.write(f&quot;sample\tfq1_num\tfq2_num\tid_match_nums\tid_match_ratio\tid_pos_match_num\tid_pos_match_ratio\n&quot;)</span><br><span class="line">        for key in fq1_unit_dict:</span><br><span class="line">           </span><br><span class="line">            if key not in fq2_unit_dict:  # 不配对reads </span><br><span class="line">                continue </span><br><span class="line">            </span><br><span class="line">            id_match_num += 1  # ID 配对reads</span><br><span class="line"></span><br><span class="line">            r1_list = fq1_unit_dict[key]</span><br><span class="line">            r2_list = fq2_unit_dict[key]</span><br><span class="line"></span><br><span class="line">            r1_pos = r1_list[-1]</span><br><span class="line">            r2_pos = r2_list[-1]</span><br><span class="line"></span><br><span class="line">            r1_front_id, r1_back_id = get_pos_info(fq1_nums,r1_pos,fq1_pos_id_dict)</span><br><span class="line">            r2_front_id, r2_back_id = get_pos_info(fq2_nums,r2_pos,fq2_pos_id_dict)</span><br><span class="line"></span><br><span class="line">            if r1_front_id != r2_front_id or r1_back_id != r2_back_id:</span><br><span class="line">                #print(key)</span><br><span class="line">                continue </span><br><span class="line">            </span><br><span class="line">            id_pos_match_num += 1  # ID及位置均配对reads</span><br><span class="line"></span><br><span class="line">            read1_info = &quot;\n&quot;.join(r1_list[0:4])</span><br><span class="line">            read2_info = &quot;\n&quot;.join(r2_list[0:4])</span><br><span class="line"></span><br><span class="line">            outfq1.write(f&quot;&#123;read1_info&#125;\n&quot;)</span><br><span class="line">            outfq2.write(f&quot;&#123;read2_info&#125;\n&quot;)</span><br><span class="line"></span><br><span class="line">        if fq1_nums &lt; fq2_nums:</span><br><span class="line">            id_pos_match_ratio = id_pos_match_num/fq2_nums</span><br><span class="line">            id_match_ratio = id_match_num/fq2_nums</span><br><span class="line">        else:</span><br><span class="line">            id_pos_match_ratio = id_pos_match_num/fq1_nums</span><br><span class="line">            id_match_ratio = id_match_num/fq1_nums</span><br><span class="line"></span><br><span class="line">        outlog.write(f&quot;&#123;prefix&#125;\t&#123;fq1_nums&#125;\t&#123;fq2_nums&#125;\t&#123;id_match_num&#125;\t&#123;id_match_ratio:.2f&#125;\t&#123;id_pos_match_num&#125;\t&#123;id_pos_match_ratio:.2f&#125;\n&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        sys.stderr.write(&quot;User interrupt me! ;-) See you!\n&quot;)</span><br><span class="line">        sys.exit(0)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用示例</span><br><span class="line">python extract.fq.from.gzrecover.v3.2.py -1 demo.R1.fq.gz -2 demo.R2.recovered -s demo</span><br><span class="line"></span><br><span class="line"># 输出结果说明</span><br><span class="line">demo_gzrecover_R1.fastq.gz  # 最终恢复后可用的fastq1文件</span><br><span class="line">demo_gzrecover_R2.fastq.gz  # 最终恢复后可用的fastq2文件</span><br><span class="line">demo.gzrecover.log          # 日志文件，</span><br></pre></td></tr></table></figure><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>在日常工作中，文件损坏的概率很小。即使文件损坏了，一般也是重新测序。然而现实总有些不同寻常，对小概率事件进行非常规操作。同时，也从侧面表明日常数据管理和备份的重要性。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1490766" target="_blank" rel="noopener">接修复损坏的gzip压缩文件之原理篇</a><br><a href="https://github.com/arenn/gzrt" target="_blank" rel="noopener">gzrecover </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;如果服务器硬盘坏了，数据恢复的可能性存在，但并不是百分之百。&lt;br&gt;&amp;emsp;&amp;emsp;首先需要知道的是，数据恢复的难度与硬盘故障的类型和程度密切相关。如果是物理损坏，比如电路板故障或者盘片划伤等，恢复的难度会非常大，而且通常无法保证能够完全恢复所有数据。如果是逻辑损坏，比如文件系统错误或者病毒攻击等，恢复的难度相对较小，但也需要根据具体情况而定。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;针对服务器数据恢复，以下是一些可能的步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;备份数据&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;在服务器硬盘损坏后，首先要做的是备份所有数据。这可以通过使用专业的数据恢复设备或者硬盘拷贝机来实现。要确保备份的数据完整性和准确性，需要在备份过程中仔细操作并检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修复硬盘&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;对于物理损坏的硬盘，需要进行修复。这通常包括更换电路板、修复盘片或者更换整个硬盘等。在这个过程中，需要非常小心，以免对硬盘造成更大的损坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据恢复&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;在备份完数据并修复好硬盘后，可以开始进行数据恢复。这通常包括在专业的数据恢复设备上对硬盘进行镜像备份、分析raid信息、尝试恢复丢失的数据等。这个过程需要专业的技能和经验，不能随意操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;需要注意的是，在数据恢复过程中，任何操作都可能对原始数据造成破坏，因此最好避免在原盘上进行数据分析、重组等操作。同时，如果发现有无法恢复的数据，不要继续尝试，以免对数据造成更大的破坏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上是常规磁盘数据恢复过程，由专业的服务器运维工程师操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当样本下机fastq.gz文件通过以上专业方式依然无法恢复时，我们可以通过生信方式尽量多的从损坏文件中获取有用信息，尽可能降低损失。&lt;/p&gt;
    
    </summary>
    
      <category term="生信" scheme="https://biofang.github.io/categories/%E7%94%9F%E4%BF%A1/"/>
    
    
      <category term="生信" scheme="https://biofang.github.io/tags/%E7%94%9F%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>03.Rust学习-解构Option</title>
    <link href="https://biofang.github.io/2024/01/24/03-Rust%E5%AD%A6%E4%B9%A0-%E8%A7%A3%E6%9E%84Option/"/>
    <id>https://biofang.github.io/2024/01/24/03-Rust学习-解构Option/</id>
    <published>2024-01-24T14:23:31.000Z</published>
    <updated>2024-01-24T14:29:21.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Option 是 Rust 语言中的一个枚举类型，它表示一个值可能存在，也可能不存在的情况。在Rust中没有空值<code>null</code>关键字，而改为使用Option枚举来处理。通过这种方式，可以解决很多问题，比如判断一个值是否为空，<code>避免空指针引用</code>等。</p><p>Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Option<t> 枚举被包含在<code>prelude</code> ( <code>prelude</code>属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中自动导入）中，在使用时不用提前导入，直接使用即可。</t></p><h3 id="2-解构-Option"><a href="#2-解构-Option" class="headerlink" title="2. 解构 Option"></a>2. 解构 Option</h3><p>想获取 Option<t> 当中的T，可以有以下几种方式：<br><a id="more"></a></t></p><h4 id="2-1-match"><a href="#2-1-match" class="headerlink" title="2.1. match"></a>2.1. match</h4><p>通过 match 表达式来判断 Option 中是否存在值，并进行相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = Some(10);</span><br><span class="line">    match a &#123;</span><br><span class="line">        Some(num) =&gt; println!(&quot;&#123;&#125;&quot;, num),</span><br><span class="line">        None =&gt; println!(&quot;&#123;&#125;&quot;, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-if-let"><a href="#2-2-if-let" class="headerlink" title="2.2. if let"></a>2.2. if let</h4><p>使用if-let 语法糖，在 if condition 的语法规则下，在 condition 部分进行 let 语句的模式解构，匹配上则执行 dosomething。if-let 和 match 的区别是，前者只关注某个感兴趣的特定分支，后者则必须完整匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = Some(10);</span><br><span class="line">    if let Some(num) = a &#123;</span><br><span class="line">        let b = 8;</span><br><span class="line">        let all = num + b;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, all);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-unwrap"><a href="#2-3-unwrap" class="headerlink" title="2.3. unwrap"></a>2.3. unwrap</h4><p>unwrap()方法不安全，但操作方便，如果目标值为 None，会引起 panic！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = Some(10);</span><br><span class="line">    let a_value = a.unwrap();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,a_value);   // 如果a为None时，会引发panic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-unwrap-or"><a href="#2-4-unwrap-or" class="headerlink" title="2.4. unwrap_or"></a>2.4. unwrap_or</h4><p>相对unwrap()，较为安全。若是出现提取失败（目标为 None），则使用参数代替输出。<br>类似方法还有unwrap_or_else()，unwrap_or_default()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // let a = Some(10);</span><br><span class="line">    let a = None;</span><br><span class="line">    let a_value = a.unwrap_or(100);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,a_value);   // 输出默认值100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-5-take"><a href="#2-5-take" class="headerlink" title="2.5. take"></a>2.5. take</h4><p>take方法可以从Option中取出值，并将 Option 中的值设置为 None，但原来的变量还有效（但实际上没什么用处了，因为只剩下None了），take方法的原始值或者引用必须为mut类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut a: Option&lt;i32&gt; = Some(5);  // 去掉mut时报错；</span><br><span class="line">    let a_value = a.take();</span><br><span class="line">    println!(&quot;The value is &#123;:?&#125;&quot;, a);</span><br><span class="line">    println!(&quot;The new Option is &#123;:?&#125;&quot;, a_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The value is None</span><br><span class="line">// The new Option is Some(5)</span><br></pre></td></tr></table></figure></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li>对于逻辑上会存在空值的变量，应该显式声明其类型为 Option<t>，否则应直接声明为 T 类型。</t></li><li>不要轻易使用 unwrap 方法，它可能会导致程序发生 panic。因为 unwrap 方法是从 Option<t> 中提取出 T，若 T 的类型为 None，则会触发 panic。一定要用也推荐用 expect, 至少 panic 时会有错误信息。</t></li><li>Option 包装的指针类型执行效率不会降低，即“零开销抽象”。</li></ul><h3 id="4-参考信息"><a href="#4-参考信息" class="headerlink" title="4. 参考信息"></a>4. 参考信息</h3><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html" target="_blank" rel="noopener">Enum std::option::Option</a><br><a href="https://course.rs/basic/compound-type/enum.html" target="_blank" rel="noopener">Rust语言圣经(Rust Course)</a><br><a href="https://zhuanlan.zhihu.com/p/577413515" target="_blank" rel="noopener">Rust的模式解构 &amp; 再谈 Option 类型</a><br><a href="https://juejin.cn/post/7222787944296742967" target="_blank" rel="noopener">Rust语言从入门到精通系列 - Option特征那些事儿</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;Option 是 Rust 语言中的一个枚举类型，它表示一个值可能存在，也可能不存在的情况。在Rust中没有空值&lt;code&gt;null&lt;/code&gt;关键字，而改为使用Option枚举来处理。通过这种方式，可以解决很多问题，比如判断一个值是否为空，&lt;code&gt;避免空指针引用&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None，定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum Option&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Some(T),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    None,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于Option&lt;t&gt; 枚举被包含在&lt;code&gt;prelude&lt;/code&gt; ( &lt;code&gt;prelude&lt;/code&gt;属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中自动导入）中，在使用时不用提前导入，直接使用即可。&lt;/t&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-解构-Option&quot;&gt;&lt;a href=&quot;#2-解构-Option&quot; class=&quot;headerlink&quot; title=&quot;2. 解构 Option&quot;&gt;&lt;/a&gt;2. 解构 Option&lt;/h3&gt;&lt;p&gt;想获取 Option&lt;t&gt; 当中的T，可以有以下几种方式：&lt;br&gt;
    
    </summary>
    
      <category term="Rust" scheme="https://biofang.github.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://biofang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>02.Rust学习-传参1</title>
    <link href="https://biofang.github.io/2024/01/17/02-Rust%E5%AD%A6%E4%B9%A0-%E4%BC%A0%E5%8F%821/"/>
    <id>https://biofang.github.io/2024/01/17/02-Rust学习-传参1/</id>
    <published>2024-01-17T14:21:23.000Z</published>
    <updated>2024-01-17T14:26:29.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Rust 是一种 静态编译的、快速的语言，具有出色的工具支持和迅速增长的生态系统，这使它非常适合编写命令行应用程序。在平时的生信分析中，大部分工具也是命令行形式。因此，从这个角度来说，Rust是非常适合应用于生信领域。作为一个命令行应用程序（CLI），最基本的要求是能够与外界进行参数传递。</p><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>一种方式是通过Rust标准库提供的std::env::args() 方法，提供了运行时给定参数的迭代器。<br>另一种是当前最受欢迎的解析命令行参数的库clap。</p><h4 id="args用法"><a href="#args用法" class="headerlink" title="args用法"></a>args用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);</span><br><span class="line">    let path = std::env::args().nth(2).expect(&quot;no path given&quot;);</span><br><span class="line">    // 直接返回迭代器中相应位置的元素；</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,pattern,path);</span><br><span class="line"></span><br><span class="line">    let args:Vec&lt;String&gt; = std::env::args().collect();</span><br><span class="line">    // 将迭代器转换为一个集合</span><br><span class="line">    dbg!(args);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    $ cargo run  --  test  tmp.txt</span><br><span class="line">    test,tmp.txt</span><br><span class="line">    [src\main.rs:12] args = [</span><br><span class="line">    &quot;target\\debug\\learn_env.exe&quot;,</span><br><span class="line">    &quot;test&quot;,</span><br><span class="line">    &quot;tmp.txt&quot;,</span><br><span class="line">    ]</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="clap用法"><a href="#clap用法" class="headerlink" title="clap用法"></a>clap用法</h4><p>使用clap库前，需要提前导入clap库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方法一</span><br><span class="line">cargo add clap --features derive</span><br><span class="line"># 方法二</span><br><span class="line">直接在Cargo.toml中添加</span><br><span class="line">clap = &#123; version = &quot;4.4.18&quot;, features = [&quot;derive&quot;] &#125;</span><br><span class="line"># 默认情况下，所有的 feature 都会被自动禁用;</span><br><span class="line"># 以上配置为 clap 依赖开启了 derive feature;</span><br></pre></td></tr></table></figure></p><p>简单案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">use clap::Parser;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let args = Cli::parse();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,args.pattern,args.path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 在文件中搜索并显示包含它的行；</span><br><span class="line">#[derive(Parser)]</span><br><span class="line">struct Cli &#123;</span><br><span class="line">    /// 要查找的模式</span><br><span class="line">    #[arg(short = &apos;s&apos;, long = &quot;pattern&quot;)]</span><br><span class="line">    pattern: String,</span><br><span class="line">    /// 要读取的文件路径</span><br><span class="line">    #[arg(short = &apos;p&apos;, long = &quot;path&quot;)]</span><br><span class="line">    path: String,</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">$ cargo run  --  -h</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.08s</span><br><span class="line">     Running `target\debug\learn_env.exe -h`</span><br><span class="line">在文件中搜索模式并显示包含它的行；</span><br><span class="line"></span><br><span class="line">Usage: learn_struct.exe --pattern &lt;PATTERN&gt; --path &lt;PATH&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -s, --pattern &lt;PATTERN&gt;  要查找的模式</span><br><span class="line">  -p, --path &lt;PATH&gt;        要读取的文件路径</span><br><span class="line">  -h, --help               Print help</span><br><span class="line"></span><br><span class="line">  很简单的，就可以打印出漂亮的帮助信息</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>clap 还有更详细的配置信息，比如子命令模式等，下次再进一步学习。毕竟现在的目标是快速上手Rust，边实战边学习。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.rs/clap/4.2.1/clap/index.html" target="_blank" rel="noopener">Crate clap</a><br><a href="https://kaisery.github.io/trpl-zh-cn/ch12-03-improving-error-handling-and-modularity.html" target="_blank" rel="noopener">Rust 程序设计语言 简体中文版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Rust 是一种 静态编译的、快速的语言，具有出色的工具支持和迅速增长的生态系统，这使它非常适合编写命令行应用程序。在平时的生信分析中，大部分工具也是命令行形式。因此，从这个角度来说，Rust是非常适合应用于生信领域。作为一个命令行应用程序（CLI），最基本的要求是能够与外界进行参数传递。&lt;/p&gt;
&lt;h3 id=&quot;获取参数&quot;&gt;&lt;a href=&quot;#获取参数&quot; class=&quot;headerlink&quot; title=&quot;获取参数&quot;&gt;&lt;/a&gt;获取参数&lt;/h3&gt;&lt;p&gt;一种方式是通过Rust标准库提供的std::env::args() 方法，提供了运行时给定参数的迭代器。&lt;br&gt;另一种是当前最受欢迎的解析命令行参数的库clap。&lt;/p&gt;
&lt;h4 id=&quot;args用法&quot;&gt;&lt;a href=&quot;#args用法&quot; class=&quot;headerlink&quot; title=&quot;args用法&quot;&gt;&lt;/a&gt;args用法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let pattern = std::env::args().nth(1).expect(&amp;quot;no pattern given&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let path = std::env::args().nth(2).expect(&amp;quot;no path given&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 直接返回迭代器中相应位置的元素；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;&amp;#123;&amp;#125;,&amp;#123;&amp;#125;&amp;quot;,pattern,path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let args:Vec&amp;lt;String&amp;gt; = std::env::args().collect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 将迭代器转换为一个集合&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dbg!(args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $ cargo run  --  test  tmp.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test,tmp.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [src\main.rs:12] args = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;target\\debug\\learn_env.exe&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;test&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;tmp.txt&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Rust" scheme="https://biofang.github.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://biofang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>01.Rust学习-文件读取</title>
    <link href="https://biofang.github.io/2024/01/16/01-Rust%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>https://biofang.github.io/2024/01/16/01-Rust学习-文件读取/</id>
    <published>2024-01-16T13:48:39.000Z</published>
    <updated>2024-01-16T14:26:57.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>使用Rust进行简单的文件读取操作。</p><h3 id="一次性读入"><a href="#一次性读入" class="headerlink" title="一次性读入"></a>一次性读入</h3><p><strong>优点：</strong></p><ul><li>处理包含字符串内容的文件；</li><li>可以一次整体处理；</li></ul><p><strong>缺点：</strong></p><ul><li>过大的文件可能会对性能产生严重影响；</li><li>文件越大，程序内存消耗就越大；</li><li>某些文件不能处理，如二进制内容的文件不能以这种方式处理；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::fs;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args:Vec&lt;String&gt;= env::args().collect();</span><br><span class="line"></span><br><span class="line">    let fpath = &amp;args[1];</span><br><span class="line"></span><br><span class="line">    let contents:String = fs::read_to_string(fpath)</span><br><span class="line">        .expect(&quot;读取文件失败&quot;);</span><br><span class="line"></span><br><span class="line">    for line in contents.lines() &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><p>Rust在其标准库提供的BufReader方法，它是在Reader方法基础之上进行了一些细节优化，这种方法可以处理以下特点的文件：</p><ul><li>包含字符串内容的文件</li><li>不能一次处理太大的文件<br>然而，这种方法也有一些缺点：</li><li>它只适用于字符串内容的文件；</li><li>实现可能很快变得更加复杂；</li><li>根据文件的格式，如果不是要处理的所有内容都放在同一行，则可能需要自己缓冲行；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use std::io::&#123; stdin, BufRead, BufReader&#125;;</span><br><span class="line">use std::env;</span><br><span class="line">use std::fs::File;</span><br><span class="line">use std::path::Path;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args:Vec&lt;String&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    let read_from : Box&lt;dyn BufRead&gt; = if args.len() &gt; 1 &#123;</span><br><span class="line">        let fpath = args.get(1).expect(&quot;cannot get argument!&quot;);</span><br><span class="line">        let file = File::open(Path::new(fpath))</span><br><span class="line">            .expect(format!(&quot;cannot open&#123;&#125;&quot;,fpath).as_str());</span><br><span class="line">        Box::new(BufReader::new(file))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Box::new(BufReader::new(stdin()))</span><br><span class="line">        // Box::new(stdin().lock())</span><br><span class="line">    &#125;;</span><br><span class="line">    for line in read_from.lines() &#123;</span><br><span class="line">        let line = line.unwrap();</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;--&#123;&#125;&quot;,line,line.len());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对于生信方面，常用的也就是按行读取文件或者全部一次性读入。当然读取文件还有其它方式，比如按字节块读取，以单个字节逐步读取等，这些方式在Rust中均能实现。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/lilpig/p/16994665.html" target="_blank" rel="noopener">Rust Read、BufRead、BufReader</a><br><a href="https://llever.com/gentle-intro/3-filesystem.zh.html" target="_blank" rel="noopener">文件系统和进程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;使用Rust进行简单的文件读取操作。&lt;/p&gt;
&lt;h3 id=&quot;一次性读入&quot;&gt;&lt;a href=&quot;#一次性读入&quot; class=&quot;headerlink&quot; title=&quot;一次性读入&quot;&gt;&lt;/a&gt;一次性读入&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理包含字符串内容的文件；&lt;/li&gt;
&lt;li&gt;可以一次整体处理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过大的文件可能会对性能产生严重影响；&lt;/li&gt;
&lt;li&gt;文件越大，程序内存消耗就越大；&lt;/li&gt;
&lt;li&gt;某些文件不能处理，如二进制内容的文件不能以这种方式处理；&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use std::env;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;use std::fs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let args:Vec&amp;lt;String&amp;gt;= env::args().collect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let fpath = &amp;amp;args[1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let contents:String = fs::read_to_string(fpath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .expect(&amp;quot;读取文件失败&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for line in contents.lines() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println!(&amp;quot;&amp;#123;&amp;#125;&amp;quot;,line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Rust" scheme="https://biofang.github.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://biofang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>kaks计算</title>
    <link href="https://biofang.github.io/2020/04/02/kaks%E8%AE%A1%E7%AE%97/"/>
    <id>https://biofang.github.io/2020/04/02/kaks计算/</id>
    <published>2020-04-02T14:06:49.000Z</published>
    <updated>2020-04-02T14:37:59.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单多线程快速计算同源基因对kaks  </p><h3 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h3><ul><li>ParaAT2.0  </li><li>KaKs_Calculator2.0  </li></ul><h3 id="ParaAT-使用说明"><a href="#ParaAT-使用说明" class="headerlink" title="ParaAT 使用说明"></a>ParaAT 使用说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/storage_wut/user/software/ParaAT2.0:$PATH</span><br><span class="line"></span><br><span class="line">cd /storage_wut/user/software/ParaAT2.0</span><br><span class="line"></span><br><span class="line">ParaAT.pl -h test.homologs -n test.cds -a test.pep -p proc -o output -f axt</span><br><span class="line">--------------------------------</span><br><span class="line">-h, 指定同源基因列表文件</span><br><span class="line">-n, 指定核酸序列文件</span><br><span class="line">-a, 指定蛋白序列文件</span><br><span class="line">-p, 指定多线程文件                      ## 文件中给定线程数，默认为6</span><br><span class="line">-m, 指定比对工具                        ## muscle</span><br><span class="line">-g, 去除比对有gap的密码子</span><br><span class="line">-k, 用KaKs_Calculator                   ## 计算kaks值</span><br><span class="line">-o, 输出结果的目录</span><br><span class="line">-f, 输出比对文件的格式</span><br></pre></td></tr></table></figure><h3 id="计算-kaks"><a href="#计算-kaks" class="headerlink" title="计算 kaks"></a>计算 kaks</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo start at time `date +%F&apos;  &apos;%H:%M:%S`</span><br><span class="line"></span><br><span class="line">export PATH=/storage_wut/user/software/ParaAT2.0:$PATH</span><br><span class="line">export PATH=/storage_wut/user/software/KaKs_Calculator2.0/bin/Linux/:$PATH</span><br><span class="line"></span><br><span class="line">cd /storage_wut/user/project/06lumeng_project/19.homologs_kaks/01.kaks</span><br><span class="line"></span><br><span class="line">ParaAT.pl -h ../00.data/A_CC.collinearity_one2one.dat -n ../00.data/homo.gene.cds.fa -a ../00.data/homo.gene.pep.fa -p proc -m muscle -f axt -g -k -o result_dir</span><br><span class="line"></span><br><span class="line">cat ./result_dir/*kaks |awk &apos;NR==1;NR&gt;=1 &#123; print $0| &quot;grep -v Sequence&quot;&#125;&apos; &gt; ../all.kaks.result.xls</span><br><span class="line">less all.kaks.result.xls  |cut -f 5|grep -v &apos;NA&apos; &gt; kaks.list</span><br><span class="line"></span><br><span class="line">echo finish at time `date +%F&apos;  &apos;%H:%M:%S`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### all.kaks.result.xls 文件格式</span><br><span class="line">Sequence        Method  Ka      Ks      Ka/Ks   P-Value(Fisher) Length  S-Sites N-Sites Fold-Sites(0:2:4)       Substitutions   S-Substitutions N-Substitutio</span><br><span class="line">Cg-F_10146-gene7838     MA      0.0194491       0.172237        0.112921        6.96313e-06     303     67.5573 235.443 NA      14      10.0464 3.95362 NA</span><br><span class="line">Cg-F_11450-gene46992    MA      0.018447        0.18238 0.101146        8.74657e-22     1335    376.13  958.87  NA      75      59.6254 15.3746 NA      NA</span><br><span class="line">Cg-F_11533-gene3021     MA      0.0364833       0.133713        0.272848        3.03892e-07     984     254.578 729.422 NA      56      31.4295 24.5705 NA</span><br><span class="line">Cg-F_11705-gene4507     MA      0.043183        0.281557        0.153372        5.71615e-10     450     99.3644 350.636 NA      37      24.007  12.993  NA</span><br><span class="line">Cg-F_11829-gene26952    MA      0.0670496       0.195014        0.343819        0.000123585     528     128.586 399.414 NA      47      22.7275 24.2725 NA</span><br><span class="line">Cg-F_12075-gene67778    MA      0.163755        0.446331        0.366892        4.00233e-08     510     129.087 380.913 NA      96      46.0956 49.9044 NA</span><br><span class="line">Cg-F_12095-gene37099    MA      0.0459748       0.131137        0.350585        3.28611e-05     1056    236.285 819.715 NA      64      28.8778 35.1222 NA</span><br><span class="line">Cg-F_12212-gene32496    MA      0.0351454       0.113734        0.309015        0.000255903     639     182.649 456.351 NA      34      19.1865 14.8135 NA</span><br><span class="line">Cg-F_12217-gene33956    MA      0.0545515       0.128713        0.423823        0.00831507      552     132.318 419.682 NA      37      15.7831 21.2169 NA</span><br></pre></td></tr></table></figure><h3 id="绘制-kaks-条形图"><a href="#绘制-kaks-条形图" class="headerlink" title="绘制 kaks 条形图"></a>绘制 kaks 条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rm(list = ls())</span><br><span class="line">library(ggplot2)</span><br><span class="line">windowsFonts(myFont = windowsFont(&quot;Times New Roman&quot;))</span><br><span class="line">setwd(&quot;D:\\gooagle_data\\work_r\\kaks&quot;)</span><br><span class="line">data &lt;- read.table(&quot;kaks.list&quot;,sep=&apos;\t&apos;)</span><br><span class="line">ggplot(data,aes(V1))+ geom_histogram(color=&apos;#39A0FE&apos;,fill=&apos;#39A0FE&apos;, binwidth = 0.5)</span><br><span class="line"></span><br><span class="line">ggplot(data,aes(V1))+ geom_histogram(fill=&apos;#39A0FE&apos;, binwidth = 0.03,color=&apos;white&apos;)+ </span><br><span class="line">  ylab(label = &apos;Number of gene pair&apos;)+xlab(label = &apos;ka/ks&apos;)+theme_classic()+</span><br><span class="line">  theme(axis.title = element_text(size=20),axis.text = element_text(size = 18,color = &quot;black&quot;))+</span><br><span class="line">  scale_x_continuous(limits = c(-0.1,5),breaks=c(0,1,2,3,4,5))</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/02/oiRKdcWrM5b9p6e.png" alt="ka/ks条形图.png">  </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hui-liu.github.io/blog/kaks%E8%AE%A1%E7%AE%97/" target="_blank" rel="noopener">kaks计算–刘辉</a><br><a href="https://zhuanlan.zhihu.com/p/82432544" target="_blank" rel="noopener">一键批量计算kaks</a><br><a href="http://www.biotrainee.com/thread-1685-1-1.html" target="_blank" rel="noopener">使用ParaAT和kaks_calculator批量Kaks批量计算</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;简单多线程快速计算同源基因对kaks  &lt;/p&gt;
&lt;h3 id=&quot;依赖工具&quot;&gt;&lt;a href=&quot;#依赖工具&quot; class=&quot;headerlink&quot; title=&quot;依赖工具&quot;&gt;&lt;/a&gt;依赖工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ParaAT2.0  &lt;/li&gt;
&lt;li&gt;KaKs_Calculator2.0  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ParaAT-使用说明&quot;&gt;&lt;a href=&quot;#ParaAT-使用说明&quot; class=&quot;headerlink&quot; title=&quot;ParaAT 使用说明&quot;&gt;&lt;/a&gt;ParaAT 使用说明&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export PATH=/storage_wut/user/software/ParaAT2.0:$PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd /storage_wut/user/software/ParaAT2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ParaAT.pl -h test.homologs -n test.cds -a test.pep -p proc -o output -f axt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-h, 指定同源基因列表文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n, 指定核酸序列文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a, 指定蛋白序列文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p, 指定多线程文件                      ## 文件中给定线程数，默认为6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m, 指定比对工具                        ## muscle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-g, 去除比对有gap的密码子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k, 用KaKs_Calculator                   ## 计算kaks值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o, 输出结果的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-f, 输出比对文件的格式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;计算-kaks&quot;&gt;&lt;a href=&quot;#计算-kaks&quot; class=&quot;headerlink&quot; title=&quot;计算 kaks&quot;&gt;&lt;/a&gt;计算 kaks&lt;/h3&gt;
    
    </summary>
    
      <category term="生信" scheme="https://biofang.github.io/categories/%E7%94%9F%E4%BF%A1/"/>
    
    
      <category term="bioinfo" scheme="https://biofang.github.io/tags/bioinfo/"/>
    
  </entry>
  
  <entry>
    <title>GO分类条形图</title>
    <link href="https://biofang.github.io/2020/04/02/GO%E5%88%86%E7%B1%BB%E6%9D%A1%E5%BD%A2%E5%9B%BE/"/>
    <id>https://biofang.github.io/2020/04/02/GO分类条形图/</id>
    <published>2020-04-02T13:24:51.000Z</published>
    <updated>2020-04-02T13:51:21.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="R-绘图脚本"><a href="#R-绘图脚本" class="headerlink" title="R 绘图脚本"></a>R 绘图脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rm(list = ls())</span><br><span class="line">library(ggplot2)</span><br><span class="line">windowsFonts(myFont = windowsFont(&quot;Times New Roman&quot;))</span><br><span class="line">setwd(&quot;D:\\data\\kegg_go_class&quot;)</span><br><span class="line">data &lt;- read.table(&quot;test.DESeq2.goClass.xls.counts&quot;,sep=&apos;\t&apos;,header = T)</span><br><span class="line">pdf(file=&quot;test.DESeq2.goClass.pdf&quot;,width=10,height=10)</span><br><span class="line">dorder = factor(as.integer(rownames(data)),labels=data$GO_term) #对数据按GO_term排序</span><br><span class="line">ggplot(data,aes(x=GO_term,y=Number_of_Genes,fill=GO_category))  +   #定义X轴，Y轴的数据和颜色填充</span><br><span class="line">  geom_bar(stat=&quot;identity&quot;,position=position_dodge(0.7),width=0.8,aes(x=dorder))  + #定义柱形图的宽度和间距</span><br><span class="line">  coord_flip() +  #转换横纵坐标</span><br><span class="line">  ylim(0,600) +</span><br><span class="line">  scale_fill_discrete(name=&quot;GO category&quot;) + #修改legend的tittle</span><br><span class="line">  theme_bw() +</span><br><span class="line">  theme(panel.grid =element_blank(),axis.text=element_text(size = 10,face = &quot;bold&quot;)) + </span><br><span class="line">  geom_text(mapping = aes(label = Number_of_Genes),size = 4,hjust = -0.5) +</span><br><span class="line">  ylab(&quot;Number of genes&quot;)  +#修改X轴标签</span><br><span class="line">  xlab(&quot;&quot;)</span><br><span class="line">dev.off()</span><br></pre></td></tr></table></figure><h3 id="绘图结果"><a href="#绘图结果" class="headerlink" title="绘图结果"></a>绘图结果</h3><p><img src="https://i.loli.net/2020/04/02/dIhn4NjaUqDfeps.png" alt="image.png"></p><a id="more"></a><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GO_termGO_categoryNumber_of_Genes</span><br><span class="line">AgingOrganismal Systems42</span><br><span class="line">Excretory systemOrganismal Systems46</span><br><span class="line">Environmental adaptationOrganismal Systems72</span><br><span class="line">Sensory systemOrganismal Systems78</span><br><span class="line">Circulatory systemOrganismal Systems80</span><br><span class="line">Digestive systemOrganismal Systems93</span><br><span class="line">DevelopmentOrganismal Systems108</span><br><span class="line">Endocrine systemOrganismal Systems207</span><br><span class="line">Immune systemOrganismal Systems225</span><br><span class="line">Nervous systemOrganismal Systems246</span><br><span class="line">Biosynthesis of other secondary metabolitesMetabolism6</span><br><span class="line">Xenobiotics biodegradation and metabolismMetabolism14</span><br><span class="line">Metabolism of terpenoids and polyketidesMetabolism19</span><br><span class="line">Metabolism of cofactors and vitaminsMetabolism23</span><br><span class="line">Energy metabolismMetabolism27</span><br><span class="line">Metabolism of other amino acidsMetabolism28</span><br><span class="line">OverviewMetabolism34</span><br><span class="line">Nucleotide metabolismMetabolism37</span><br><span class="line">Glycan biosynthesis and metabolismMetabolism40</span><br><span class="line">Amino acid metabolismMetabolism52</span><br><span class="line">Carbohydrate metabolismMetabolism56</span><br><span class="line">Lipid metabolismMetabolism78</span><br><span class="line">TranscriptionGenetic Information Processing7</span><br><span class="line">Replication and repairGenetic Information Processing9</span><br><span class="line">TranslationGenetic Information Processing25</span><br><span class="line">Folding, sorting and degradationGenetic Information Processing55</span><br><span class="line">Membrane transportEnvironmental Information Processing9</span><br><span class="line">Signaling molecules and interactionEnvironmental Information Processing229</span><br><span class="line">Signal transductionEnvironmental Information Processing517</span><br><span class="line">Cellular community - prokaryotesCellular Processes6</span><br><span class="line">Cell motilityCellular Processes47</span><br><span class="line">Cell growth and deathCellular Processes146</span><br><span class="line">Cellular community - eukaryotesCellular Processes158</span><br><span class="line">Transport and catabolismCellular Processes163</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;R-绘图脚本&quot;&gt;&lt;a href=&quot;#R-绘图脚本&quot; class=&quot;headerlink&quot; title=&quot;R 绘图脚本&quot;&gt;&lt;/a&gt;R 绘图脚本&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rm(list = ls())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;library(ggplot2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;windowsFonts(myFont = windowsFont(&amp;quot;Times New Roman&amp;quot;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setwd(&amp;quot;D:\\data\\kegg_go_class&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data &amp;lt;- read.table(&amp;quot;test.DESeq2.goClass.xls.counts&amp;quot;,sep=&amp;apos;\t&amp;apos;,header = T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pdf(file=&amp;quot;test.DESeq2.goClass.pdf&amp;quot;,width=10,height=10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dorder = factor(as.integer(rownames(data)),labels=data$GO_term) #对数据按GO_term排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ggplot(data,aes(x=GO_term,y=Number_of_Genes,fill=GO_category))  +   #定义X轴，Y轴的数据和颜色填充&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  geom_bar(stat=&amp;quot;identity&amp;quot;,position=position_dodge(0.7),width=0.8,aes(x=dorder))  + #定义柱形图的宽度和间距&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  coord_flip() +  #转换横纵坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ylim(0,600) +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  scale_fill_discrete(name=&amp;quot;GO category&amp;quot;) + #修改legend的tittle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  theme_bw() +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  theme(panel.grid =element_blank(),axis.text=element_text(size = 10,face = &amp;quot;bold&amp;quot;)) + &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  geom_text(mapping = aes(label = Number_of_Genes),size = 4,hjust = -0.5) +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ylab(&amp;quot;Number of genes&amp;quot;)  +#修改X轴标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  xlab(&amp;quot;&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dev.off()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘图结果&quot;&gt;&lt;a href=&quot;#绘图结果&quot; class=&quot;headerlink&quot; title=&quot;绘图结果&quot;&gt;&lt;/a&gt;绘图结果&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/02/dIhn4NjaUqDfeps.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生信" scheme="https://biofang.github.io/categories/%E7%94%9F%E4%BF%A1/"/>
    
    
      <category term="R" scheme="https://biofang.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>效率工具集(不定期更新。。。)</title>
    <link href="https://biofang.github.io/2019/12/19/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>https://biofang.github.io/2019/12/19/效率工具集/</id>
    <published>2019-12-19T15:24:36.000Z</published>
    <updated>2020-04-02T13:51:51.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h3><ul><li><a href="https://saladict.crimx.com/" target="_blank" rel="noopener">Saladict 沙拉查词</a>  </li><li><a href="https://github.com/Selection-Translator/crx-selection-translate#readme" target="_blank" rel="noopener">划词翻译</a> </li><li><a href="https://adblockplus.org/" target="_blank" rel="noopener">Adblock Plus</a>  </li><li><a href="https://chrome.google.com/webstore/detail/chrono/cdipjnbignkeledopgpgdlgbolhgkben" target="_blank" rel="noopener">Chrono</a>    </li><li><a href="https://www.infinitynewtab.com/" target="_blank" rel="noopener">infinity</a>  </li><li><a href="https://chrome.google.com/webstore/detail/simpleundoclose/emhohdghchmjepmigjojkehidlielknj" target="_blank" rel="noopener">SimpleUndoClose</a>   </li><li><a href="https://www.scholarscope.cn/index.html" target="_blank" rel="noopener">Scholarscope</a>  <a id="more"></a></li></ul><h3 id="优秀软件"><a href="#优秀软件" class="headerlink" title="优秀软件"></a>优秀软件</h3><ul><li><a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener">Everything</a>    </li><li><a href="https://u.tools/" target="_blank" rel="noopener">uTools</a>  </li><li><a href="https://yuanliao.info/t/plugins" target="_blank" rel="noopener">uTools第三方插件</a>  </li><li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>    </li><li><a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a>  </li><li><a href="https://copytranslator.github.io/" target="_blank" rel="noopener">CopyTranslator</a>  </li><li><a href="http://www.9312.net/download.html" target="_blank" rel="noopener">SCI-HUB文献神器</a>  </li><li><a href="https://sunlogin.oray.com/personal/" target="_blank" rel="noopener">向日葵</a>  </li><li><a href="https://powerkeys.github.io/" target="_blank" rel="noopener">Power Keys</a>  </li><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>  </li><li><a href="https://tamlok.github.io/vnote/zh_cn/" target="_blank" rel="noopener">VNote</a>    </li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>    </li><li><a href="https://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a>  </li><li><a href="http://1218.io/" target="_blank" rel="noopener">Seer</a>  </li><li><a href="https://ditto-cp.sourceforge.io/" target="_blank" rel="noopener">Ditto</a>    </li><li><a href="https://www.chuyu.me/zh-Hans/" target="_blank" rel="noopener">Dism++</a>  </li><li><a href="https://www.ccleaner.com/" target="_blank" rel="noopener">CCleaner</a>  </li><li><a href="https://github.com/Tyrrrz/LightBulb" target="_blank" rel="noopener">LightBulb</a>  </li><li><a href="https://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a>    </li><li><a href="https://github.com/atom/atom" target="_blank" rel="noopener">Atom</a>  </li><li><a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text 3</a>  </li></ul><h3 id="Office-插件"><a href="#Office-插件" class="headerlink" title="Office 插件"></a>Office 插件</h3><ul><li><a href="http://oktools.xyz/" target="_blank" rel="noopener">OneKeyTools</a>  </li><li><a href="https://www.islide.cc/" target="_blank" rel="noopener">iSlide</a>  </li><li><a href="https://www.papocket.com/" target="_blank" rel="noopener">口袋动画</a>  </li><li><a href="http://meihua.docer.com/" target="_blank" rel="noopener">PPT美化大师</a>   </li><li><a href="https://addins.cn/yhtools/" target="_blank" rel="noopener">LvyhTools</a>  </li><li><a href="https://easychart.github.io/post/Easycharts/" target="_blank" rel="noopener">EasyCharts</a>  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Chrome-插件&quot;&gt;&lt;a href=&quot;#Chrome-插件&quot; class=&quot;headerlink&quot; title=&quot;Chrome 插件&quot;&gt;&lt;/a&gt;Chrome 插件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://saladict.crimx.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Saladict 沙拉查词&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Selection-Translator/crx-selection-translate#readme&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;划词翻译&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://adblockplus.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adblock Plus&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/chrono/cdipjnbignkeledopgpgdlgbolhgkben&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrono&lt;/a&gt;    &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infinitynewtab.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infinity&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/simpleundoclose/emhohdghchmjepmigjojkehidlielknj&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SimpleUndoClose&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.scholarscope.cn/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Scholarscope&lt;/a&gt;
    
    </summary>
    
      <category term="工具" scheme="https://biofang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>python赋值、浅拷贝和深拷贝</title>
    <link href="https://biofang.github.io/2019/04/14/python%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://biofang.github.io/2019/04/14/python赋值、浅拷贝和深拷贝/</id>
    <published>2019-04-14T15:29:02.000Z</published>
    <updated>2019-04-14T15:42:00.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;python中关于对象复制有三种类型：直接赋值、浅拷贝和深拷贝，他们既有联系又有区别。在python中，“类型”属于“对象”，“变量”是没有“类型”的。所有的变量都可以理解是内存中一个对象的“引用”。所以，我们需要把“变量”和真正的“内存对象”分开。   </p><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>&emsp;&emsp;在python中赋值语句是建立对象的引用值，而不是复制对象。因此，python变量更像是指针，而不是数据存储区域。因此，直接赋值其实就是其实就是对象的引用（别名）。<br><a id="more"></a></p><h3 id="浅拷贝-copy"><a href="#浅拷贝-copy" class="headerlink" title="浅拷贝(copy)"></a>浅拷贝(copy)</h3><p>拷贝父对象，不会拷贝对象的内部的子对象，浅拷贝仅仅复制了容器中元素的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; testList = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br><span class="line">&gt;&gt;&gt; testListCopy = testList</span><br><span class="line">&gt;&gt;&gt; testList</span><br><span class="line">    [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testListCopy</span><br><span class="line">    [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testList.pop(1)   ## 删除testList一个元素</span><br><span class="line">    &apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; testList</span><br><span class="line">    [&apos;a&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testListCopy     ## testListCopy也发生了改变 </span><br><span class="line">    [&apos;a&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><h3 id="深拷贝-deepcopy"><a href="#深拷贝-deepcopy" class="headerlink" title="深拷贝(deepcopy)"></a>深拷贝(deepcopy)</h3><p>&emsp;&emsp;如果不想出现上面的情况（testListCopy随意testList改变而改变），需要使用深拷贝（deepcopy）方法。<br>&emsp;&emsp;copy模块的deepcopy方法可以完全拷贝了父对象及其子对象。深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from copy import deepcopy   ## 导入copy模块</span><br><span class="line">&gt;&gt;&gt; testList = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br><span class="line">&gt;&gt;&gt; testListDeepCopy = deepcopy(testList)</span><br><span class="line">&gt;&gt;&gt; testList</span><br><span class="line">    [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testListDeepCopy</span><br><span class="line">    [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testList.pop(0)    ## 删除testList中的元素</span><br><span class="line">    &apos;a&apos;</span><br><span class="line">&gt;&gt;&gt; testList.pop(1)</span><br><span class="line">    &apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; testList</span><br><span class="line">    [&apos;b&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt; testListDeepCopy   ## testListDeepCopy没有发生改变</span><br><span class="line">    [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/woxiaohahaa/article/details/78606155" target="_blank" rel="noopener">理解python里的赋值、引用、拷贝及作用域、内存管理、垃圾回收</a>  </p><p><a href="https://my.oschina.net/leejun2005/blog/145911" target="_blank" rel="noopener">python基础(5)：深入理解python中的赋值、引用、拷贝、作用域</a>  </p><p><a href="https://wecatch.me/blog/2016/06/18/python-copy-deepcopy/" target="_blank" rel="noopener">你真得理解python的浅拷贝和深拷贝吗？</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;python中关于对象复制有三种类型：直接赋值、浅拷贝和深拷贝，他们既有联系又有区别。在python中，“类型”属于“对象”，“变量”是没有“类型”的。所有的变量都可以理解是内存中一个对象的“引用”。所以，我们需要把“变量”和真正的“内存对象”分开。   &lt;/p&gt;
&lt;h3 id=&quot;直接赋值&quot;&gt;&lt;a href=&quot;#直接赋值&quot; class=&quot;headerlink&quot; title=&quot;直接赋值&quot;&gt;&lt;/a&gt;直接赋值&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在python中赋值语句是建立对象的引用值，而不是复制对象。因此，python变量更像是指针，而不是数据存储区域。因此，直接赋值其实就是其实就是对象的引用（别名）。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://biofang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://biofang.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Xmind快捷键详解（思维导图版）</title>
    <link href="https://biofang.github.io/2018/11/15/Xmind%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://biofang.github.io/2018/11/15/Xmind快捷键/</id>
    <published>2018-11-15T08:39:34.000Z</published>
    <updated>2020-04-02T12:20:13.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>软件版本：<code>XMind 8 Update 7</code>  </li><li>操作系统：  <code>Windows 10</code>  </li><li>剪切画： 部分剪切画从外部导入    </li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><a id="more"></a><p><img src="https://s1.ax1x.com/2020/04/02/GYDJM9.png" alt="快捷键思维导图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;软件版本：&lt;code&gt;XMind 8 Update 7&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;操作系统：  &lt;code&gt;Windows 10&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;剪切画： 部分剪切画从外部导入    &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;
    
    </summary>
    
      <category term="工具" scheme="https://biofang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Xmind" scheme="https://biofang.github.io/tags/Xmind/"/>
    
  </entry>
  
  <entry>
    <title>Xshell完美连接win10 Linux子系统</title>
    <link href="https://biofang.github.io/2018/11/08/xshell-%E5%AE%8C%E7%BE%8E%E8%BF%9E%E6%8E%A5win10-Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://biofang.github.io/2018/11/08/xshell-完美连接win10-Linux子系统/</id>
    <published>2018-11-08T09:39:21.000Z</published>
    <updated>2018-11-13T16:07:26.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求简介"><a href="#需求简介" class="headerlink" title="需求简介"></a>需求简介</h2><p>自从微软向全世界发布<code>Windows 10</code>下的 <code>Linux</code>子系统<code>Windows Subsystem for Linux(WSL)</code>，<code>WSL</code>为<code>Windows</code>用户提供了巨大的便利，它的诞生可以让开发者们在 <code>Windows 10</code> 下通过 <code>Bash shell</code> 运行原生态的<code>Ubuntu</code> 系统。当然，目前有很多方式在<code>Windows</code>系统下体验和学习<code>Linux</code>系统，主要包括以下几种方式：  </p><ul><li>虚拟机<br>通过在<code>Windows</code>系统下安装虚拟机<code>Virtual Machine</code>运行<code>Linux</code>系统，是目前比较流行的方式。但是运行虚拟机也有诸多不便，比如：消耗内存大（土豪随意）；划分的硬盘主机无法访问；与主机传输文件容易中断等。  <a id="more"></a></li><li>双系统<br>给电脑安装双系统，在电脑启动的时候选择其中一种系统。这种方式对于<code>Windowns</code>深度用户比较麻烦，需要频繁开机更换系统。  </li><li>服务器<br>租用服务器或购买服务器一般比较昂贵，如果仅仅是学习或偶尔用下完全没必要破费。  </li><li><code>Windows 10</code>下<code>Linux</code>子系统<br>通过简单的操作可以激活打开<code>Linux</code>,体验原生态的<code>Ubuntu</code>，前提是能够忍受默认的终端界面（当然是有解决方法的）。  </li></ul><h2 id="使用xshell登录Linux子系统"><a href="#使用xshell登录Linux子系统" class="headerlink" title="使用xshell登录Linux子系统"></a>使用xshell登录Linux子系统</h2><p>成功激活<code>WSL</code>后，能够忍受默认的命令终端的可以直接跳过下文。<br>习惯用<code>Linux</code>系统的用户，一般喜欢使用<code>Xshell</code>通过<code>SSH</code>登录<code>Linux</code>系统，然后在界面优美的命令端操作<code>Linux</code>命令。<br>以下来介绍如何完美使用<code>Xshell</code>登录<code>Windows 10</code> <code>Linux</code>子系统:  </p><ul><li><p>查看<code>ip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig  ## 在Linux子系统默认命令端输入，查看ip地址</span><br></pre></td></tr></table></figure></li><li><p>配置<code>SSH</code>服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge openssh-server   ## 先删ssh</span><br><span class="line">sudo apt-get install openssh-server          ## 在安装ssh  </span><br><span class="line"></span><br><span class="line">sudo rm /etc/ssh/ssh_config                  ## 删配置文件，让ssh服务自己想办法链接</span><br><span class="line">sudo service ssh --full-restart</span><br></pre></td></tr></table></figure></li><li><p>使用<code>xshell</code>登录</p></li></ul><p>上面命令执行完之后，在<code>Xshell</code>中输入用户名和<code>ip</code>就可以通过<code>Xshell</code>登录自己电脑的<code>Linux</code>。  </p><ul><li>配置永久解决方案<br>通过上面的方法，我们可以通过<code>Xshell</code>登录自己电脑的<code>Linux</code>。但是断开之后重新开机，我们又需要重新配置<code>SSH</code>。因此，我们需要配置以下命令下，一劳永逸。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh --full-restart   ## 将该命令保存为service.sh，存在home目录下</span><br></pre></td></tr></table></figure></li></ul><p>配置好之后，下次开机，只需要在<code>Linux</code>子系统的默认终端运行<code>sh service.sh</code>命令后，关掉终端改用<code>xshell</code>登录即可。  </p><ul><li>配置自己的环境变量<br>以上设置成功后，可以<code>vim ~/.bashrc</code>配置自己的环境变量，打造自己习惯的界面显示。  </li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/raoweijian/article/details/65661302" target="_blank" rel="noopener">通过 Xshell 连接 ubuntu on windows(WSL)</a><br><a href="https://www.cnblogs.com/ACDIV/p/9047825.html" target="_blank" rel="noopener">win10上使用Xshell通过ssh连接Linux</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求简介&quot;&gt;&lt;a href=&quot;#需求简介&quot; class=&quot;headerlink&quot; title=&quot;需求简介&quot;&gt;&lt;/a&gt;需求简介&lt;/h2&gt;&lt;p&gt;自从微软向全世界发布&lt;code&gt;Windows 10&lt;/code&gt;下的 &lt;code&gt;Linux&lt;/code&gt;子系统&lt;code&gt;Windows Subsystem for Linux(WSL)&lt;/code&gt;，&lt;code&gt;WSL&lt;/code&gt;为&lt;code&gt;Windows&lt;/code&gt;用户提供了巨大的便利，它的诞生可以让开发者们在 &lt;code&gt;Windows 10&lt;/code&gt; 下通过 &lt;code&gt;Bash shell&lt;/code&gt; 运行原生态的&lt;code&gt;Ubuntu&lt;/code&gt; 系统。当然，目前有很多方式在&lt;code&gt;Windows&lt;/code&gt;系统下体验和学习&lt;code&gt;Linux&lt;/code&gt;系统，主要包括以下几种方式：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机&lt;br&gt;通过在&lt;code&gt;Windows&lt;/code&gt;系统下安装虚拟机&lt;code&gt;Virtual Machine&lt;/code&gt;运行&lt;code&gt;Linux&lt;/code&gt;系统，是目前比较流行的方式。但是运行虚拟机也有诸多不便，比如：消耗内存大（土豪随意）；划分的硬盘主机无法访问；与主机传输文件容易中断等。
    
    </summary>
    
      <category term="技术" scheme="https://biofang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://biofang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法详解</title>
    <link href="https://biofang.github.io/2018/11/05/Markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://biofang.github.io/2018/11/05/Markdown语法详解/</id>
    <published>2018-11-05T01:36:16.000Z</published>
    <updated>2020-04-02T13:52:08.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>ps: 本文<code>Markdown</code>语法均在有道云笔记中测试和修改，不同平台显示有所差异。  </p><h2 id="Markdown概述"><a href="#Markdown概述" class="headerlink" title="Markdown概述"></a><code>Markdown</code>概述</h2><p><code>Markdown</code>是一种轻量级的简单易学的标记语言，通过简单的标记语法，可以使普通文本内容具有一定标记格式。其文本格式为<code>.md</code>类似于<code>html</code>，只不过标签更简单，更易读易写，可以方便转换为<code>html</code>、<code>pdf</code>等格式。<br><code>Markdown</code>不是一种编程语言，其目标也不会代替html，但是其非常适用于写文档，书写博客等。一旦上手<code>Markdown</code>后，写作会成为一种享受。<br><a id="more"></a></p><h2 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h2><ul><li>学习成本低，只需要简单掌握十几个符号用法就可以；  </li><li>纯文本，兼容性强，所有的文本编辑器都支持；  </li><li>让用户专注于内容而不是排版；  </li><li><code>Markdown</code>可以随意转换为<code>html</code>，<code>pdf</code>，<code>md</code>格式的；  </li><li>标记语法具有良好的可读性。  <h2 id="Markdown缺点"><a href="#Markdown缺点" class="headerlink" title="Markdown缺点"></a>Markdown缺点</h2></li><li>对图片的支持度不像<code>word</code>等那么方便；</li><li>不同<code>Markdown</code>编辑器语法有细微差别。</li></ul><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>Markdown</code>中插入不同级别的标题操作非常方便，只需要插入不同数量的<code>#</code>即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#        一级标题</span><br><span class="line">##       二级标题</span><br><span class="line">###      三级标题</span><br><span class="line">####     四级标题</span><br><span class="line">#####    五级标题</span><br><span class="line">######   六级标题</span><br><span class="line"></span><br><span class="line">注意： #与标题之间一般需要空一格。</span><br><span class="line">备注：以上为Markdown中演示内容，实际书写中呈大小梯度变化。</span><br></pre></td></tr></table></figure></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表分为有序列表和无序列表，两者在实现上有些差异。有序列表顾名思义是有逻辑数字顺序的，如1、2、3等，而无序列表仅仅是以一种无差异符号表示内容的并列关系。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p><code>Markdown</code>中支持多种符号实现无序列表格式化，如<code>-</code>，<code>*</code>，<code>+</code>，其效果均相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- aaa</span><br><span class="line">- bbb</span><br><span class="line">- ccc</span><br><span class="line">---</span><br><span class="line">* AAA</span><br><span class="line">* BBB</span><br><span class="line">* CCC</span><br><span class="line">---</span><br><span class="line">+ 111</span><br><span class="line">+ 222</span><br><span class="line">+ 333</span><br><span class="line">---</span><br><span class="line">- aaa    # 不同符号之间也可以混用，外观上相同，但间距变大。。。</span><br><span class="line">* BBB</span><br><span class="line">+ 333</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果</p><hr><ul><li>aaa</li><li>bbb</li><li>ccc</li></ul><hr><ul><li>AAA</li><li>BBB</li><li>CCC</li></ul><hr><ul><li>111</li><li>222</li><li>333</li></ul><hr><ul><li>aaa</li></ul><ul><li>BBB</li></ul><ul><li>333</li></ul><hr><p><strong>备注：</strong> 因为<code>-</code>符号操作最方便只需要按一下按键，建议最好使用<code>-</code>符号实现无序列表。  </p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><h4 id="同等级有序列表"><a href="#同等级有序列表" class="headerlink" title="同等级有序列表"></a>同等级有序列表</h4><p>实现同一等级的有序列表，只需要数字加上点号（小数点和英文格式的句号均可以），且与输出的内容中间空一格即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">---</span><br><span class="line">1. aaa</span><br><span class="line">2. bbb</span><br><span class="line">3. ccc</span><br><span class="line">---</span><br><span class="line">1. aaa</span><br><span class="line">3. ccc</span><br><span class="line">2. bbb</span><br><span class="line">---</span><br><span class="line">111. AAA     # 多位数字也可以</span><br><span class="line">112. BBB</span><br><span class="line">113. CCC</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果</p><hr><ol><li>aaa</li><li>bbb</li><li>ccc</li></ol><hr><ol><li>aaa</li><li>ccc</li><li>bbb</li></ol><hr><ol start="111"><li>AAA</li><li>BBB</li><li>CCC</li></ol><hr><h4 id="多级有序列表"><a href="#多级有序列表" class="headerlink" title="多级有序列表"></a>多级有序列表</h4><p>目前，在一般<code>Markdown</code>语法中多等级有序列表没有完美的实现方法，但能通过结合无序列表方法折中解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 1\. aaa       # 注意&apos;.&apos;前要加反斜杠转义。。。</span><br><span class="line">    - 1.1 bbb</span><br><span class="line">    - 1.2 ccc</span><br><span class="line">- 2\. bbb</span><br><span class="line">    - 2.1 aba</span><br><span class="line">    - 2.2 bab</span><br><span class="line">- 3\. ccc</span><br><span class="line">    - 3.1 aca</span><br><span class="line">    - 3.2 cac</span><br><span class="line">        - 3.2.1 eee</span><br><span class="line">        - 3.2.2 ggg</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果</p><ul><li>1. aaa<ul><li>1.1 bbb</li><li>1.2 ccc</li></ul></li><li>2. bbb<ul><li>2.1 aba</li><li>2.2 bab</li></ul></li><li>3. ccc<ul><li>3.1 aca</li><li>3.2 cac<ul><li>3.2.1 eee</li><li>3.2.2 ggg</li></ul></li></ul></li></ul><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>在<code>Markdown</code>中实现分割线也可以通过<code>-</code>，<code>*</code>，<code>+</code>三种符号完成。具体实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">------     # 可以使用三个以上符号，*和+ 效果相同</span><br><span class="line">-  -    -  # 符号之间可以加上多个空格</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong> 使用<code>-</code>插入分割线时，需要与上面的内容之间至少空一行，否则 <code>Markdown</code>会将上一行内容解释为二级标题。  </p><hr><hr><hr><h2 id="字体修饰"><a href="#字体修饰" class="headerlink" title="字体修饰"></a>字体修饰</h2><p><code>Markdown</code>中字体修饰主要包含：<code>字体</code>，<code>加粗</code>，<code>斜体</code>，<code>下划线</code>，<code>大小</code>，<code>上色</code>，<code>背景色</code>等。  </p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><code>Markdown</code>中无原生语法修饰字体，但我们可以借鉴<code>HTML</code>语法实现相关效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br></pre></td></tr></table></figure></p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font>  <h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><p><code>Markdown</code>中实现字体加粗方式有以下几种（大家选择顺手的就可以~~~）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**加粗**               # 推荐用法</span><br><span class="line">__加粗__               # 英文状态的下划线</span><br><span class="line">&lt;b&gt;加粗&lt;/b&gt;  </span><br><span class="line">&lt;strong&gt;加粗&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果<br><strong>加粗</strong><br><strong>加粗</strong><br><b>加粗</b><br><strong>加粗</strong></p><ul><li>字体斜体  </li></ul><p><code>Markdown</code>中实现斜体也有以下几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*  </span><br><span class="line">_斜体_  </span><br><span class="line">&lt;em&gt;斜体&lt;/em&gt;</span><br></pre></td></tr></table></figure></p><p><em>斜体</em><br>_斜体_<br><em>斜体</em>  </p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p><code>Markdown</code>中并无原生语法的实现下划线，但可以借鉴<code>HTML</code>和<code>css</code>中的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++下划线++     # 有道云中可以实现</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;  </span><br><span class="line">&lt;span style=&quot;border-bottom:2px dashed red;&quot;&gt;下划线&lt;/span&gt;  </span><br><span class="line">&lt;span style=&quot;border-bottom:2px solid red;&quot;&gt;下划线&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果<br>++下划线++<br><u>下划线</u><br><span style="border-bottom:2px dashed red;">下划线</span><br><span style="border-bottom:2px solid red;">下划线</span>  </p><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>借鉴<code>HTML</code>语法可以在<code>Markdown</code>中调整字体大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=4&gt;字体大小&lt;/font&gt;  </span><br><span class="line">&lt;font size=6&gt;字体大小&lt;/font&gt;</span><br></pre></td></tr></table></figure></p><font size="4">字体大小</font><br><font size="6">字体大小</font><h3 id="字体上色"><a href="#字体上色" class="headerlink" title="字体上色"></a>字体上色</h3><p>借鉴<code>HTML</code>语法也可以在<code>Markdown</code>中实现字体上色效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=gray size=4&gt;字体上色&lt;/font&gt;  </span><br><span class="line">&lt;font color=red size=4&gt;字体上色&lt;/font&gt;</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果  </p><font color="gray" size="4">字体上色</font><br><font color="red" size="4">字体上色</font>    <h3 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h3><p><code>Markdown</code>中也无原生语法的实现下划线，但有道云中可以通过以下方式实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==字体背景色==    # 有道云中可以，其他平台还未测试</span><br></pre></td></tr></table></figure></p><p><code>Markdown</code>下实现效果<br>==字体背景色==  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行代码"><a href="#行代码" class="headerlink" title="行代码"></a>行代码</h3><p>单行代码引用使用单个<code>符号（符号位于ESC键下方），实现代码着色。</code>Markdown`下实现效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`行代码`,`Markdown`</span><br></pre></td></tr></table></figure></p><p><code>行代码</code>,<code>Markdown</code>   </p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>将代码置于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Markdown`下实现效果</span><br></pre></td></tr></table></figure></p><p>​<figure class="highlight plain"><figcaption><span>显示需要，Markdown中不需要加</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码块</span><br><span class="line">代码块</span><br><span class="line">​```    # 显示需要，Markdown中不需要加</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码块</span><br><span class="line">代码块</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>Markdown</code>中引用的符号是<code>&gt;</code>，使用时<code>&gt;</code>与引用内容间要空一格。大概可分为普通引用和嵌套引用，具体使用方法如下：  </p><h3 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h3><p><code>Markdown</code>下实现效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用内容1  </span><br><span class="line">引用内容2      # 引用内容后不空行的话，后面均为引用内容，只需要在第一行加上&apos;&gt;&apos;符号即可。</span><br><span class="line">引用内容3</span><br><span class="line"></span><br><span class="line">&gt; 引用内容a  </span><br><span class="line">&gt; 引用内容b  </span><br><span class="line">&gt; 引用内容c</span><br></pre></td></tr></table></figure></p><blockquote><p>引用内容1<br>引用内容2<br>引用内容3  </p></blockquote><blockquote><p>引用内容a<br>引用内容b<br>引用内容c</p></blockquote><h3 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h3><p>在引用中加入不同数量的<code>&gt;</code>符号可以表示不同等级。<br><code>Markdown</code>下实现效果    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用1    #从少到多可以直接实现，如果多到少则不能实现（ps有道云）。</span><br><span class="line">&gt;&gt; 引用2  </span><br><span class="line">&gt;&gt;&gt; 引用3</span><br></pre></td></tr></table></figure><blockquote><p>引用1  </p><blockquote><p>引用2  </p><blockquote><p>引用3  </p></blockquote></blockquote></blockquote><h3 id="引用内修饰"><a href="#引用内修饰" class="headerlink" title="引用内修饰"></a>引用内修饰</h3><p>引用内容内也可以加入字体加粗、代码引用等语法修饰，突出显示内容。<br><code>Markdown</code>下实现效果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; **加粗**  </span><br><span class="line">&gt; *斜体*  </span><br><span class="line">&gt; `代码`</span><br></pre></td></tr></table></figure><blockquote><p><strong>加粗</strong><br><em>斜体</em><br><code>代码</code></p></blockquote><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://www.baidu.com)</span><br><span class="line">[百度](http://www.baidu.com &quot;这是备注&quot;)  # 可以添加备注</span><br><span class="line">&lt;http://www.baidu.com/&gt;                  # 自动链接  </span><br><span class="line">&lt;fangj@163.com&gt;                          # 也可以通过链接方式自动生成电子邮件</span><br></pre></td></tr></table></figure><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a><br><a href="http://www.baidu.com" title="这是备注" target="_blank" rel="noopener">百度</a><br><a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a><br><a href="mailto:&#x66;&#97;&#x6e;&#x67;&#x6a;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x66;&#97;&#x6e;&#x67;&#x6a;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;</a>  </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><code>Markdown</code>中图片插入的方式与和链接非常相似，差别只是在<code>[]</code>前加上<code>！</code>。<br>如果要在网络上分享文章，需要提前将图片放到图床上，获得图片的链接，当然也可以直接在网络上寻找图片。如果只是在本地查看，则可以根据图片相对路径或绝对路径插入到文中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![星空](http://seopic.699pic.com/photo/50021/5261.jpg_wh1200.jpg)</span><br><span class="line">![星空](http://seopic.699pic.com/photo/50021/5261.jpg_wh1200.jpg &quot;备注&quot;)  # 也可以备注信息</span><br></pre></td></tr></table></figure></p><p><img src="http://seopic.699pic.com/photo/50021/5261.jpg_wh1200.jpg" alt="星空">  </p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.jianshu.com/p/q81RER#" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a><br><a href="https://github.com/CompileYouth/front-end-study/blob/master/tool/markdown/Markdown-Learning.md" target="_blank" rel="noopener">front-end-study from github</a><br><a href="https://frankbing.gitbooks.io/markdown/content/" target="_blank" rel="noopener">Markdown使用笔记</a><br><a href="https://blog.csdn.net/testcs_dn/article/details/45719357" target="_blank" rel="noopener">CSDN-markdown编辑器语法——字体、字号与颜色</a><br><a href="http://itmyhome.com/markdown/index.html" target="_blank" rel="noopener">Learning-Markdown (Markdown 入门参考)</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Markdown简介&quot; class=&quot;headerlink&quot; title=&quot;Markdown简介&quot;&gt;&lt;/a&gt;Markdown简介&lt;/h1&gt;&lt;p&gt;ps: 本文&lt;code&gt;Markdown&lt;/code&gt;语法均在有道云笔记中测试和修改，不同平台显示有所差异。  &lt;/p&gt;
&lt;h2 id=&quot;Markdown概述&quot;&gt;&lt;a href=&quot;#Markdown概述&quot; class=&quot;headerlink&quot; title=&quot;Markdown概述&quot;&gt;&lt;/a&gt;&lt;code&gt;Markdown&lt;/code&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Markdown&lt;/code&gt;是一种轻量级的简单易学的标记语言，通过简单的标记语法，可以使普通文本内容具有一定标记格式。其文本格式为&lt;code&gt;.md&lt;/code&gt;类似于&lt;code&gt;html&lt;/code&gt;，只不过标签更简单，更易读易写，可以方便转换为&lt;code&gt;html&lt;/code&gt;、&lt;code&gt;pdf&lt;/code&gt;等格式。&lt;br&gt;&lt;code&gt;Markdown&lt;/code&gt;不是一种编程语言，其目标也不会代替html，但是其非常适用于写文档，书写博客等。一旦上手&lt;code&gt;Markdown&lt;/code&gt;后，写作会成为一种享受。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://biofang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Markdown" scheme="https://biofang.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
